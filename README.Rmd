---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# hyAggregate

<!-- badges: start -->
[![Dependencies](https://img.shields.io/badge/dependencies-6/91-orange?style=flat)](#)
[![R CMD Check](https://github.com/mikejohnson51/hyAggregate/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/mikejohnson51/hyAggregate/actions/workflows/R-CMD-check.yaml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://choosealicense.com/licenses/mit/)
[![LifeCycle](man/figures/lifecycle/lifecycle-experimental.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

The goal of `hyAggregate` is to aggregate refactored (see [hyRefactor](https://github.com/dblodgett-usgs/hyRefactor)) hydrologic networks to meet user defined length and area minimum thresholds

## Installation

You can install the released version of `hyAggregate` from [Github](https://CRAN.R-project.org) with:

``` r
remotes::install_github("mikejohnson51/hyAggregate")
```

## Example

This is a basic example which shows you how hyAggrgate works. The core premise is that outputs from `hyRefactor` can be aggregated to meet minimum catchment area and flowpath length criteria.

Here we aggregate the refactored network draining to USGS-01013500 to an ideal size of 10sqkm, with a minimum allowable catchment area of 3sqkm and a minimum allowable flowpath length of 1 km.

```{r example, message  = FALSE, warning=FALSE}
library(hyAggregate)
library(dplyr)
library(sf)

load(system.file("extdata", "gage_01013500.rda", package = "hyAggregate"))

aggregated = aggregate_by_thresholds(fl = gage_01013500$flowpaths,
                                     catchments = gage_01013500$catchments,
                                     ideal_size = 10,
                                     min_area_sqkm = 3,
                                     min_length_km = 1)
```

Here we can view a map of the modified flowpath and catchment network. Note that aggregating any network will result in lost resolution on the network when data conforms to the HY_Feature standand.

```{r, echo = FALSE}
par(mfrow = c(1,2))
plot(st_geometry(gage_01013500$catchments), border = "red")
plot(st_geometry(aggregated$catchments), border = "blue", add = TRUE)

plot(st_geometry(gage_01013500$flowpaths), col = "red")
plot(st_geometry(aggregated$flowpaths), col = "blue", add= TRUE, lwd = 2)
```

Equally we can ensure that our critieria was met by evaluating the catchment area and flowpath lengths across outputs:

```{r, echo = FALSE}
{par(mfrow = c(2,2))
hist(gage_01013500$catchments$areasqkm, 
     breaks = 100, main = "Refactored Catchment Areas",
     xlab = "SqKM")
abline(v = 3, lwd = 4)
abline(v = 10, lwd = 4)
abline(v = 15, lwd = 4)
hist(aggregated$catchments$areasqkm, 
     breaks = 100, main = "Aggregated Catchment Areas",
     xlab = "SqKM")
abline(v = 3, lwd = 4)
abline(v = 10, lwd = 4)
abline(v = 15, lwd = 4)

hist(gage_01013500$flowpaths$LENGTHKM, 
     breaks = 100, main = "Refactored Flowpath Lengths",
     xlab = "KM")
abline(v = 1, lwd = 4)
hist(aggregated$flowpaths$lengthkm, 
     breaks = 100, main = "Aggregated Flowpath Lengths",
     xlab = "KM")
abline(v = 1, lwd = 4)
}
```

